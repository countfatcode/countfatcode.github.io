[{"title":"afl-tmin.c源码阅读","path":"/2024/01/27/afl源码阅读/","content":"afl-tmin.c源码阅读分析过程从main-&gt;set_up_environment-&gt;read_initial_file-&gt;run_target-&gt;minimize函数 1234567891011```c-i: 指定输入文件-o: 指定输出文件-f:-e: 是否只考虑 edge-x: 是否将程序状态非零返回值视为crash-m: 设置内存限制-t: 程序运行时间限制-B: 加载 bitmap-V: 显示版本信息 0x0 main函数解析完参数后，main函数剩下的代码如注释所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 检查是否缺少必须参数 if (optind == argc || !in_file || !out_file) usage(argv[0]); // 创建共享内存，将shm id写入到环境变量，供桩代码使用 setup_shm(); setup_signal_handlers(); // 设置 signal handler，用户手动结束程序时使用 set_up_environment(); // 设置环境变量 // 根据参数寻找binary find_binary(argv[optind]); // 分析程序传入的输入（--之后的那部分，如果有@@，则把它写入到输入文件位置 prog_in） detect_file_args(argv + optind); // qemu相关参数设置 if (qemu_mode) use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind); else use_argv = argv + optind; exact_mode = !!getenv(&quot;AFL_TMIN_EXACT&quot;); SAYF(&quot; &quot;); // 检查输入的文件是否大于10MB // 将输入读到 in_data 中 // 计算输入长度存入到 in_len read_initial_file(); // 输出相应的提示 ACTF(&quot;Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...&quot;, mem_limit, exec_tmout, edges_only ? &quot;, edges only&quot; : &quot;&quot;); // dru run 检查程序执行是否超时，是否crash, r, 该保留un_target直接使用execv执行程序 run_target(use_argv, in_data, in_len, 1); if (child_timed_out) FATAL(&quot;Target binary times out (adjusting -t may help).&quot;); if (!crash_mode) &#123; OKF(&quot;Program terminates normally, minimizing in &quot; cCYA &quot;instrumented&quot; cRST &quot; mode.&quot;); if (!anything_set()) FATAL(&quot;No instrumentation detected.&quot;); &#125; else &#123; OKF(&quot;Program exits with a signal, minimizing in &quot; cMGN &quot;%scrash&quot; cRST &quot; mode.&quot;, exact_mode ? &quot;EXACT &quot; : &quot;&quot;); &#125; // 执行minimize优化 minimize(use_argv); ACTF(&quot;Writing output to &#x27;%s&#x27;...&quot;, out_file); // 删除prog_in并优化输出结果 unlink(prog_in); prog_in = NULL; close(write_to_file(out_file, in_data, in_len)); OKF(&quot;We&#x27;re done here. Have a nice day! &quot;); exit(0); 在main函数中，setup_shm、read_initial_file、run_target、minimize函数比较重要，接下来逐个分析这些函数。 0x1 setup_shm函数在setup_shm中主要进行三个操作： 创建共享内存，大小为65535字节，分配可执行权限 将shm_id设置为环境变量__AFL_SHM_ID 将共享内存attach到当前进程地址空间 1234567891011121314151617181920212223242526272829static void setup_shm(void) &#123; u8 *shm_str; // 创建共享内存 // IPC_PRIVATE = 0 shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); if (shm_id &lt; 0) PFATAL(&quot;shmget() failed&quot;); // 调用 remove_shm 删除共享内存 // atexit 会在程序正常终止时执行 atexit(remove_shm); shm_str = alloc_printf(&quot;%d&quot;, shm_id); setenv(SHM_ENV_VAR, shm_str, 1); ck_free(shm_str); // 将共享区域挂载到调用进程地址空间 // 返回共享内存连接的起始地址 trace_bits = shmat(shm_id, NULL, 0); if (trace_bits == (void *)-1) PFATAL(&quot;shmat() failed&quot;);&#125; 0x2 read_initial_file函数函数代码如下。该函数做的事就是打开初始种子文件并将其读入到内存中。 123456789101112131415161718192021222324static void read_initial_file(void) &#123; struct stat st; s32 fd = open(in_file, O_RDONLY); if (fd &lt; 0) PFATAL(&quot;Unable to open &#x27;%s&#x27;&quot;, in_file); if (fstat(fd, &amp;st) || !st.st_size) FATAL(&quot;Zero-sized input file.&quot;); if (st.st_size &gt;= TMIN_MAX_FILE) FATAL(&quot;Input file is too large (%u MB max)&quot;, TMIN_MAX_FILE / 1024 / 1024); in_len = st.st_size; in_data = ck_alloc_nozero(in_len); ck_read(fd, in_data, in_len, in_file); close(fd); OKF(&quot;Read %u byte%s from &#x27;%s&#x27;.&quot;, in_len, in_len == 1 ? &quot;&quot; : &quot;s&quot;, in_file);&#125; 0x3 run_target函数函数代码如下，代码解释见注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175static u8 run_target(char **argv, u8 *mem, u32 len, u8 first_run) &#123; static struct itimerval it; int status = 0; s32 prog_in_fd; u32 cksum; // trace_bits 指向共享内存区域，在 setup_shm 中被初始化 memset(trace_bits, 0, MAP_SIZE); // 约束编译器，避免过度优化 MEM_BARRIER(); // 将 input 内容写进 prog_in 指向的文件中 // prog_in 在 set_up_environment 函数中被初始化 // 返回文件描述符 prog_in_fd = write_to_file(prog_in, mem, len); child_pid = fork(); if (child_pid &lt; 0) PFATAL(&quot;fork() failed&quot;); // 子进程执行 if (!child_pid) &#123; struct rlimit r; // stdin 指向输入文件，stdout 和 stderr 重定向到 /dev/null // 做这一步是避免待测程序崩溃产生的输出到屏幕 if (dup2(use_stdin ? prog_in_fd : dev_null_fd, 0) &lt; 0 || dup2(dev_null_fd, 1) &lt; 0 || dup2(dev_null_fd, 2) &lt; 0) &#123; *(u32 *)trace_bits = EXEC_FAIL_SIG; PFATAL(&quot;dup2() failed&quot;); &#125; close(dev_null_fd); close(prog_in_fd); // 创建新会话并成为领头进程，脱离父进程会话和进程组 // 由于会话对控制终端的独占性，子进程会同时脱离终端控制 setsid(); // mem_limit 与命令行传入参数进行关联 // 如果没有则为0 if (mem_limit) &#123; r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) &lt;&lt; 20;#ifdef RLIMIT_AS // 进程可用存储区的最大总长度（字节），这影响sbrk和mmap函数 setrlimit(RLIMIT_AS, &amp;r); /* Ignore errors */#else // 进程可用数据段最大长度（初始化数据、非初始化数据和堆数据的总和） setrlimit(RLIMIT_DATA, &amp;r); /* Ignore errors */#endif /* ^RLIMIT_AS */ &#125; r.rlim_max = r.rlim_cur = 0; // core文件的最大字节数，值为0则表示禁止创建core文件 setrlimit(RLIMIT_CORE, &amp;r); /* Ignore errors */ // 执行程序 execv(target_path, argv); // 若失败则把 trace_bits 前4个字节置为 0xfee1dead // 此时有三种可能：execv正常调用并执行；execv正常调用但执行崩溃；execv调用失败 // EXEC_FAIL_SIG和status_code可以用来判断这三种情况 *(u32 *)trace_bits = EXEC_FAIL_SIG; exit(0); // 退出程序 &#125; // end of child close(prog_in_fd); /* Configure timeout, wait for child, cancel timeout. */ // 设置定时器 child_timed_out = 0; it.it_value.tv_sec = (exec_tmout / 1000); it.it_value.tv_usec = (exec_tmout % 1000) * 1000; // SIGALRM 的 handler 此前已经被设为 [kill 掉 child_pid] // setitimer 提供高精度定时器 setitimer(ITIMER_REAL, &amp;it, NULL); // 等待子进程 if (waitpid(child_pid, &amp;status, 0) &lt;= 0) FATAL(&quot;waitpid() failed&quot;); // 取消定时器 child_pid = 0; it.it_value.tv_sec = 0; it.it_value.tv_usec = 0; setitimer(ITIMER_REAL, &amp;it, NULL); // 编译器约束 MEM_BARRIER(); /* Clean up bitmap, analyze exit condition, etc. */ // 检查 execv 是否执行成功 if (*(u32 *)trace_bits == EXEC_FAIL_SIG) FATAL(&quot;Unable to execute &#x27;%s&#x27;&quot;, argv[0]); // 对 hit count 分桶 classify_counts(trace_bits); // 配合 -B 选项使用, 统计所有edge则没有影响 apply_mask((u32 *)trace_bits, (u32 *)mask_bitmap); total_execs++; if (stop_soon) &#123; SAYF(cRST cLRD &quot; +++ Minimization aborted by user +++ &quot; cRST); close(write_to_file(out_file, in_data, in_len)); exit(1); &#125; /* Always discard inputs that time out. */ if (child_timed_out) &#123; missed_hangs++; return 0; &#125; /* Handle crashing inputs depending on current mode. */ if (WIFSIGNALED(status) || (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR) || (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) &amp;&amp; exit_crash)) &#123; // 第一次运行则使用该模式 if (first_run) crash_mode = 1; if (crash_mode) &#123; // 如果是第一次运行 ，且不要求 crash 路径与原路径相同，则立即报告该input有效, 该保留 if (!exact_mode) return 1; &#125; else &#123; // non-crash mode, 但是现在 crash, 说明这个 input 与 原input路径不同，该丢弃 missed_crashes++; return 0; &#125; &#125; else /* Handle non-crashing inputs appropriately. */ if (crash_mode) &#123; // 目标程序没有 crash, 但是现在处于 crash_mode, 则本input与原input路径不同，该丢弃 missed_paths++; return 0; &#125; // 对 shm 计算 hash，注意这里是分桶之后的 hit count cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST); if (first_run) orig_cksum = cksum; // 若本 input 与 原始input的 cksum相同，则input有效，予以保留 if (orig_cksum == cksum) return 1; missed_paths++; return 0;&#125; 0x4 minimize函数分析待更新… 参考","tags":["笔记"],"categories":["模糊测试"]},{"title":"2023心愿单","path":"/2023/09/01/心愿单/","content":"论文+1 漏洞编号 比赛 开源项目","tags":["随记"],"categories":["日常"]},{"title":"模糊测试","path":"/2023/09/01/fuzz/","content":"种子选择与引导机制 有没有新边被覆盖 旧边被覆盖的次数有所增长（有种子走重复的路，应该剔除） 如何记录已经被覆盖的边？ bitmap记录被覆盖的边以及被覆盖的次数 边覆盖引导优于块覆盖引导（块覆盖可能会遗漏边） 第一个问题边覆盖引导的问题？（有些路径会被丢弃） 第一个问题：局部路径引导机制 状态空间爆炸问题？（增大状态空间 or 算法层面进行降维） 基本块引导 &amp;rarr; 边覆盖引导 &amp;rarr; 局部路径引导 &amp;rarr; 状态引导（清华大学2022年最新文章，顶会）（循环次数？循环到一定次数触发crash） &amp;rarr; 第二个问题当种子都无法到达目的，但是一个种子比一个种子更接近，afl无法区分这两种种子的差别（基于比较进度的引导机制）ABCDEF or ABCDEF 第三个问题：哈希冲突清华大学（张超老师）解决方案：CollAFL（公众号：fuzzwiki）当两条边的哈希值一样，afl认为新边是出现过的，会丢弃该边 AFL种子筛选机制 AFL插桩 二进制插桩：pin、dynamoRio、Frida、Dyninst、QEMU 模糊测试平台：（qemu + 模糊测试技术）、（仿真 + 模糊测试技术） AFL fork server 接口模糊测试 一个一个函数接口做模糊测试工作量大，如何解决上下文环境依赖关系 上下文识别依赖及表达问题 harness自动化问题 参数间依赖问题 深度网络模糊测试 对webAPI做模糊测试 人工智能模型模糊测试 数据库模糊测试 逻辑漏洞：SQLancer黑盒、基于生成：SQLsmith灰盒、变异：Squirrel 永中别用达梦数据库（武汉大学教授出来创业） IOT固件分析操作系统: Linux、RT-Linux、VxWorkds、Android国产操作系统: 天迈、瑞云、 NOR Flash&#x2F;EEPROM: 字节寻址 元器件封装方式：SOP、BGA 文件系统: NTFS 固件提取 官网下载（工控设备基本不提供） 在线升级抓包分析固件下载 JTAG&#x2F;SWD等调试接口读取硬件：J-Link、J-link ob、st-link软件：J-Flash限制：只适用于留有调试接口的主板 编程器读取硬件：RT809H编程器（转换口）软件：编程器软件方式：飞线、拆下flash芯片 串口uboot提取软件：串口通信工具Uboot命令：bdinfo、flinfor、md 固件加密 固件分析工具 Binwalk Firmwalker Firmadyne（动态分析工具） 医疗、电力（设备不经过分析不让使用、需求缺口比较大） WeXoposed框架","tags":["笔记"],"categories":["模糊测试"]},{"title":"博客模板","path":"/2023/09/01/blog-template/","content":"博客模板","tags":["随记"],"categories":["记录"]},{"title":"Hello World","path":"/2023/03/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":["随记"],"categories":["日常"]}]